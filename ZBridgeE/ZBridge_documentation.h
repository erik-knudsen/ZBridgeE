/* Erik Aagaard Knudsen.
 Copyright © 20013 - All Rights Reserved

 Project: ZBridge
 File: ZBridge_documentation.h
 Developers: eak

 Revision History:
 13-feb-2013 eak: Original

 Abstract: Documentation.

 Platforms: Qt.
 */

/**
 * @file
 * Documentation of ZBridge application.
 */

/** @mainpage
 *
 * @section intro_sec Introduction
 * The ZBridge application is a program for bridge players who want to play bridge
 * on a computer.\n
 * This documentation documents the software.
 *
 * @section design_sec Software Design
 * The design is centered around a few important objects.\n
 *
 * Most of the objects are singletons.
 *
 * @image html SoftwareDesign_Overview.jpg "Overview of software design"
 *\n\n\n
 *
 * The application structure follows the usual Qt application structure.\n\n
 *
 * The application is started by the CZBridgeApp object. This object owns the CZBridgeDoc
 * object, which holds most of the data for the application (mostly configuration data).
 * The CZBridgeApp also owns the CMainFrame object, which controls the main menu and user
 * interaction with the main menu.\n\n
 *
 * The CMainFrame object instantiates the CTblMngr controller and the CPlayView view.\n
 * The CPlayView shows the bridge table, user interaction with the table and other in-
 * formation related to the bridge play.\n\n
 *
 * The CTblMngr (instantiated as either CTblMngrServer or CTblMngrClient) controls the
 * user interaction with the bridge table. In the server (or standalone) role it controls
 * the 4 actors (bridge players). They can be either local or on a remote client. In the
 * client role it controls one local (on the client) actor.\n\n
 *
 * Communication with remote actors (bridge players) goes through CRemoteActorServer for
 * the server and CRemoteActorClient for the client.\n\n
 *
 * Local actors are implemented based on a state and action table generated by Yakindu.
 * The server is implemented based on another state and action table generated by
 * Yakindu. The Yakindu statecharts closely implements the @ref protocol extended in
 * a few places.\n\n
 *
 * Actors can be either manual or automatic.\n
 * Manual actors are controlled by a user i.e. the user bids and plays the cards.\n
 * Automatic actors are controlled by the computer i.e. the computer bids and plays
 * the cards.\n\n
 *
 * The Qt signal/slot mechanism is used extensively. The Qt event mechanism is used
 * instead in a few places, where it seemed more natural.\n
 * Communication from table manager to actors and to playview is by means of direct
 * method calls. Communication from actors and playview to table manager is by means
 * of signals.
 */


/** @page protocol Blue Chip Bridge (basic and advanced) protocol for Inter-Program Communication
 *
 * <b>NETWORKING OF COMPUTER BRIDGE PROGRAMS</b>\n
 *
 * <b>A PROTOCOL FOR INTER-PROGRAM COMMUNICATION</b>\n

 * Version 18  <b>basic protocol</b> (1 August 2005)\n
 * <i><b>Version 20  advanced protocol (1 January 2014)</b></i>\n\n
 *
 * <b>Introductory</b>\n
 *
 *   - This draft protocol suggests a method by which bridge programs can communicate with each other in
 *     order to play bridge.\n
 *
 *   - The basic concept is that there are five programs, ideally running on five separate computers.
 *     One program plays for each hand. The fifth program acts as the "Table Manager". The Table Manager’s
 *     function is to deal the cards, transmit and receive all communications among the playing programs,
 *     keep the score and (to a limited extent) enforce the rules of the game.
 *
 *   - All communications are in plain-text ASCII format (characters #10, #13 and #32 to #127 only), using
 *     TCP/IP. It has been suggested that all 8-bit ASCII characters should be allowed for e.g. accented
 *     characters, but this might cause display problems for receiving computers (opinions please).
 *
 *   - Note that no provision is made for handling transmission time-outs.
 *
 *   - Before communications are initiated, the Table Manager’s IP address is given to the operators of the
 *     playing computers. In a LAN, this may instead be the network name of the Table Manager’s computer. Each
 *     computer will communicate with the Table Manager on a unique port, which should be agreed in advance
 *     with the Table Manager's operator. The port numbers should be within the standard range of 1024 to 5000.
 *
 *   - Before communications are initiated, each pair decides on a team name and all four players decide on
 *     their seating positions.
 *
 *   - The Table Manager opens four server sockets and waits to receive messages.
 *
 *   - Hereafter, all messages are enclosed (for identification purposes only) in quotation marks. The quotation
 *     marks will not form part of the actual message. Variables are enclosed in square brackets.  In the actual
 *     message, both the square brackets and their contents will be replaced by the appropriate value.  All
 *     messages are to be terminated by <return><line-feed> (ASCII #13#10).
 *
 *   - In messages, [Bidder], [Player], [Dummy] and [Hand] will be replaced by the players’ seat positions :
 *     North, South, East or West (as appropriate).
 *
 *   - Most messages are in plain English, so that the transmissions will be intelligible to operators and
 *     observers without decoding.
 *
 *   - Messages are not case-sensitive, so recipients (i.e. any program receiving a message) should mask all
 *     messages to a single-case and trim leading and trailing spaces before interpreting. However, because
 *     messages may optionally be displayed by programs, it is strongly recommended that they are generated by
 *     playing programs with appropriate casing, e.g. "North bids 3NT" rather than "north bids 3nt".
 *
 *   - Throughout this protocol, a space (ASCII #32) is a single space. Additional spaces; or double spaces must
 *     not be inserted into messages where they are not defined in the protocol.
 *
 *   - The deals are loaded by the Table Manager from a pre-existing PBN (Portable Bridge Notation) file. The
 *     Table Manager’s operator identifies the file for the Table Manager and specifies the number of boards to
 *     be played. As this is a local function of the Table Manager software, it is not discussed further here.
 *
 *   - The protocol has been designed so that a single message is transmitted by a client to the Table Manager
 *     and a single message is transmitted in return.
 *
 *   - <i><b>The Blue Chip Bridge protocol version 18 is called the basic protocol in the following. An enhanced
 *     protocol is also described. This protocol is called the advanced protocol (version 20). It is described
 *     in the text as deviations from the basic protocol. It eliminates the race conditions in the basic
 *     protocol and adds a few synchronization points to the client/server communication. It also makes it possible
 *     to perform undo and other similar functions. The deviations to the basic protocol are clearly marked in the
 *     following text.</b></i>
 *
 *
 * <b>Message summary</b>
 *
 * The following is an outline of the scheme of exchange of messages transmitted by the clients (<i>italic</i>) and the
 * Table Manager (<b>block</b>). The messages are summarised and are defined in detail in the following sections.\n
 * <i><b>The message summary is for the basic protocol. Deviations for the advanced protocol is described in the
 * explanation of the points in the summary.</b></i>
 *
 *   1.  <i>Connecting</i>
 *   2.  <b>Seated</b>
 *   3.  <i>Ready for team names</i>
 *   4.  <b>Team names</b>
 *   5.  <i>Ready to start</i>\n\n
 *   6.  <b>Start of board</b>
 *   7.  <i>Ready for deal</i>
 *   8.  <b>Cards</b>\n\n
 *   9.  <i>Bidder bids x (bidder) or Ready for bidder's bid (others)</i>
 *   10. <b>Transmit bid</b>
 *   11. [Loop to 9 until end of auction. If action passed out and not end of round, go to 6]\n\n
 *   12. <i>Ready for leader's card	(except leader, or declarer when dummy is leader)</i>
 *   13. <b>Leader to lead (only to leader)</b>
 *   14. <i>Leader plays x (leader)</i>
 *   15. <b>Transmit card 1</b>
 *   16. <i>Ready for dummy (only trick 1 and except dummy)</i>
 *   17. <b>Dummy's cards (only trick 1 and except dummy)</b>
 *   18. <i>Second hand plays x (second hand) or Ready for second hand's card (others)</i>
 *   19. <b>Transmit card 2</b>
 *   20. <i>Third hand plays x	(third hand) or Ready for third hand's card (others)</i>
 *   21. <b>Transmit card 3</b>
 *   22. <i>Fourth hand plays x (fourth hand) or Ready for fourth hand's card (others)</i>
 *   23. <b>Transmit card 4</b>\n\n
 *   24. Table Manager pauses for one second\n\n
 *   25. [loop to 12 until end of board]
 *   26. [loop to 6 until end of round]
 *   27. <b>End of session</b>
 *
 * \n
 * <b>Connecting</b>\n
 *
 *   1. To connect with the Table Manager, a player opens a client socket to the Table Manager’s computer.
 *      The player sends "Connecting ["team name"] as [Hand] using protocol version [x]".  The team-name
 *      should be enclosed in double-quotation marks (ASCII #34) to avoid any conflict with reserved words
 *      used in this protocol.  So that the team-name can be used as part of a file-name for hand records etc.,
 *      it should consist only of characters which would be valid as part of a file-name.  If a set of boards
 *      is replayed as part of a match with the same pairs but in rotated seats, exactly the same team-names
 *      as were used in the first set must be used in the second set.  If the Table Manager detects an
 *      irregularity (e.g. seat taken, seat not specified, the pair not using the same team-name or a player
 *      using the opponents' team name), it will transmit an error message and close the connection.  The
 *      protocol version number is as stated at the top of this page.  If the version number does not match
 *      Table Manager's protocol version number, the connection will be rejected.\n\n
 *   2. From now on, each player’s messages start with the player’s name ("North", "South", "East" or "West").
 *      Except for the special case of declarer playing dummy’s cards (discussed below), if a message prefixed
 *      by a player’s name does not match the socket allocated to that player by the Table Manager, the Table
 *      Manager will ignore the message.\n\n
 *   3. Technically, the Table Manager's server sockets can identify the origin of the client socket message,
 *      but it is proposed that TCP/IP is kept out of the specification and reliance is placed solely on ASCII
 *      messages. This will also allow future migration to non-TCP/IP systems without major change to the
 *      specification.\n\n
 *   4. On receipt of a valid log-on message, the Table Manager allocates the player to the appropriate seat
 *      and sends to the player "[Hand] ("[team-name]") seated".\n\n
 *   5. The player responds "[Hand] ready for teams".\n\n
 *   6. When all four players have connected successfully, the Table Manager sends to each player
 *      "Teams : N/S : "[N/S team name]". E/W : "[E/W team name]"". Note that the inner quotation marks are
 *      literal. They are the delimiters of the team name and will be included in the message.\n\n
 *   7. Each player responds "[Hand] ready to start".\n\n
 *
 * \n
 * <b>Dealing</b>\n
 *
 *   0. The advanced protocol makes scoring information for a set of games for Table Manager and clients
 *      complete and identical. To achieve this the protocol is enhanced with protocol messages to transfer
 *      Portable Bridge Notation files from Table Manager to clients. This part of the advanced protocol
 *      is described in the appendix @ref PBNProtocol "PBN Protocol"
 *
 *   1. At the start of each board, the Table Manager sends to each player "Start of board".\n
 *      <i><b>The advanced protocol inserts a synchronization point for rounds following the first. This might
 *      be when a round is finished and the next round is about to be started or when the user decides that a
 *      new board should be started although the current is not finished. The synchronization eliminates race
 *      conditions between Table Manager and clients. It also makes it possible to insert a waiting point for
 *      interaction with the user (show results etc.). The synchronization protocol is described in the
 *      appendix @ref synchronization "Synchronization Protocol".</b></i> \n\n
 *   2. Each player responds by sending "[Hand] ready for deal".  The message must not be sent before receipt
 *      of the "Start of board" message.\n\n
 *   3. The Table Manager (having set up a deal) sends information about the deal to each player.\n\n
 *   4. The deal information, consisting of four elements, is in the following format :
 *      - "Board number [a number determined by the Table Manager]"
 *      - "Dealer [the name (North/South/East/West) of the dealer]"
 *      - "Neither vulnerable", "N/S vulnerable", "E/W vulnerable" or "Both vulnerable" (as appropriate)
 *      - Each of the first three elements is separated from the next by a full-stop (ASCII #46) and a space (ASCII #32).
 *      - As always, the entire string is terminated by #13#10.\n\n
 *   5. Each player sends "[Hand] ready for cards".\n\n
 *   6. When all four hands are ready for their cards, the Table Manager replies to each hand with :\n
 *      "[Player]’s cards : [player’s hand]"\n
 *      <i><b> The advanced protocol sends all cards to all hands.</b></i>\n
 *   7. A hand of cards is in the following format :
 *        - The first letter of the suit (S, H, D or C) followed by a space (ASCII #32). Preferably, the suits
 *          should be specified in that order (spades, hearts, diamonds, clubs).
 *        - The initial letter of the value of each card in the suit (A K Q J T 9 8 7 6 5 4 3 2). Note that 10
 *          is represented as T so that each card is a single character. Each character is separated from the next
 *          by a space. The cards should be specified in descending order.
 *        - The last card in each suit is followed by a full-stop.
 *        - A void suit is indicated by a dash (ASCII #45).
 *   8. <i><b>The advanced protocol inserts a synchronization point before the bidding phase (auction) is entered.
 *      The synchronization eliminates race conditions between Table Manager and clients. It also makes it possible
 *      to insert a waiting point for interaction with the user (Start Auction). The synchronization protocol is
 *      described in the appendix @ref synchronization "Synchronization Protocol".</b></i>
 *
 *\n
 * <b>Bidding</b>\n
 *
 *   1. A bid is the following format :
 *     - The message starts with [bidder’s name] followed by a space.
 *     - The bid is "passes", "doubles", redoubles" or "bids " [level] (as a digit) + [trump letter-string
 *       (S, H, D, C or NT)].
 *     - If appropriate, the bid is followed by alert information (see next section).\n\n
 *   2. Dealer makes an opening bid.\n\n
 *   3. Each player (other than the next player to bid) sends "[Player] ready for [bidder]'s bid".\n\n
 *   4. The Table Manager re-transmits the bid to the other three players <i><b>(the advanced protocol
 *      re-transmits the bid to all players)</b></i>. If the bid has been alerted (see below), the Table
 *      manager re-transmits the alert and associated information to the bidder's opponents, but not to
 *      the bidder's partner.\n\n
 *   5. The next hand bids.\n\n
 *   6. This sequence continues until the auction is complete.\n
 *      <i><b>The advanced protocol inserts a synchronization point before the playing phase is entered.
 *      The synchronization eliminates race conditions between Table Manager and clients. It also makes it possible
 *      to insert a waiting point for interaction with the user (Start Play). The synchronization protocol is
 *      described in the appendix @ref synchronization "Synchronization Protocol".</b></i>\n\n
 *   7. If the hand is passed out, each player sends "[Player] ready for deal" to the Table Manager and the
 *      sequence re-commences as above.\n\n
 *   8. If the Table Manager receives an illegal bid, it will ignore it and respond "Illegal bid" to the bidder.
 *      It is assumed that playing programs will ensure that they do not make illegal bids so, at this stage in
 *      development, the protocol does not define what will then happen.
 *
 *\n
 * <b>Alerting (introductory note)</b>\n
 * <i><b>Alerting is implemented as part of a bid database in the advanced protocol and not as described below for
 * the basic protocol.</b></i>
 *
 *   1. In standard bridge played between humans, a bidder's partner is required to inform his/her opponents
 *      of an artificial bid or call (as defined by the laws of bridge).   Such a bid or call is referred to
 *      here generically as an "alertable bid" (i.e. to include non-penalty doubles and redoubles).  The next
 *      hand may then ask the bidder's partner for information about the bid or call.\n
 *      In computer v computer and computer v human bridge, the World Bridge Federation and the American
 *      Contract Bridge league have decided that the bidder should alert its/his own bid and provide information
 *      about the bid.  Bidder's partner should not be made aware of the alert nor of any information provided
 *      by the bidder.\n\n
 *   2. In order to avoid the complication either of human intervention (where the computer's operator decides
 *      that his/her program does not understand the meaning of an opponent's bid) or of a decision-making
 *      process by the program making the next bid, it is proposed that the next bidder will be deemed always
 *      to ask for information about the alertable bid.\n\n
 *   3. This protocol does not specify which bids are to be alerted or what information is to be given; nor is
 *      it concerned with the penalties for failing to alert or failing to provide correct information about
 *      a bid.  Those are matters for the relevant conditions of contest.  The Table Manager will not validate
 *      the alert.  Any dispute about the need for, or accuracy of, an alert should be referred to the
 *      tournament director outside of the Table Manager system.\n
 *      In passing, it should be noted that the general laws of bridge provide that the information required
 *      to be supplied is only information which has not already been disclosed as a result of earlier bidding.
 *      If bidder voluntarily gives additional information, that is acceptable within this protocol (although
 *      unnecessary).
 *
 *\n
 * <b>Alerting (implementation)</b>\n
 * <i><b>Alerting is implemented as part of a bid database in the advanced protocol and not as described below for
 * the basic protocol.</b></i>
 *
 *   1. An alertable bid is in the following format :\n
 *      [bid (as defined above)] [space] "Alert." [full-stop (ASCII #46) space] followed by information as
 *      defined in the next section.\n\n
 *   2. Alert information consists of one or more of :
 *     - "[n] cards in [suit]" (repeated for each relevant suit)
 *     - "up to [n] cards in [suit]" (repeated for each relevant suit)
 *     - "at least [n] cards in [suit]" (repeated for each relevant suit)
 *     - "[n1] to [n2] cards in [suit]" (repeated for each relevant suit)
 *     - "[n] total points"
 *     - "up to [n] total points"
 *     - "at least [n] total points"
 *     - "[n1] to [n2] total points"
 *     - "[n] points in [suit]" (repeated for each relevant suit)
 *     - "up to [n] points in [suit]" (repeated for each relevant suit)
 *     - "at least [n] points in [suit]" (repeated for each relevant suit)
 *     - "[n1] to [n2] points in [suit]" (repeated for each relevant suit)
 *     - "[n] total aces"
 *     - "[n] total kings"
 *     - "ace of [suit]" (repeated for each relevant suit)
 *     - "king of [suit]" (repeated for each relevant suit)
 *     - "Asking for aces"
 *     - "Asking for kings"
 *     - "Asking for a major suit"
 *     - "Asking for a four-card major suit"
 *     - "Asking for a five-card major suit"
 *     - "Asking for a minor suit"
 *     - "Asking for a four-card suit"
 *     - "Asking for support"
 *     - "Asks for lead in [suit]"
 *     - "Asks for lead not in [suit]"
 *     - "Forcing for one round"
 *     - "Forcing until game"
 *     - "Promises a rebid"\n\n
 *   3. The message is a single string.  Each element is separated from the next by a comma (ASCII #44) and
 *      one space.  The string is terminated by a full-stop.\n\n
 *   4. Alternative meanings : if a bid may have an alternative meaning, each additional complete conjunctive
 *      statement after the first should be started by "Alternatively," and terminated by a full-stop
 *      (ASCII #46), for example :\n
 *      "3NT Alert.  8 to 14 total points,  8 to 10 points in clubs, up to 6 cards in clubs.  Alternatively,
 *      8 to 14 total points,  8 to 10 points in diamonds, up to 6 cards in diamonds."\n
 *      Note that this is not necessarily an accurate description of a gambling 3NT opening bid, but simply used as an example. Note also the repetition of "8 to 14 total points" because it applies to both cases.
 *      It is envisaged that bids with more than three alternative meanings would not be permitted by the
 *      conditions of contest.\n\n
 *   5. A future possible extension of the protocol might be that simple alternative information could be given
 *      by including a single "or" between the two numbers.\n
 *      For example, 5C after a Blackwood 4NT bid may be defined as "5C Alert. 0 or 4 total aces".
 *      However, to avoid the complication of interpreting multiple "ors" or priorities between "and"s and
 *      "or"s, only one "or" may be included in a segment of information, and that, only between numeric values.\n\n
 *   6. Points refer to the Milton Work count (Ace = 4, King = 3, Queen = 2, Jack = 1), adjusted as required
 *      for length, shortages, etc.  Where an adjustment is made, the bidding program's human operator must be
 *      prepared to justify the adjustment in case of dispute.\n\n
 *   7. n1 must be less than or equal to n2.  For total points, n is in the range 0 .. 50 (40 Milton Work
 *      points + up to 10 points for distribution). For suit points, n is in the range 0 .. 15 (10 Milton
 *      Work points + up to 5 points for distribution).  For card length, n is in the range 0 .. 13.\n\n
 *   8. The name of any convention producing the alertable bid will not be mentioned.  Not only would naming
 *      the convention add extraneous information, but it will imply a requirement to have prior understanding
 *      of the meaning of bids under that convention.\n\n
 *   9. Opinions please : should the elements of the alert message be in a fixed order ?\n\n
 *
 *\n
 * <b>Pausing for manual alerting</b>\n
 * <i><b>Alerting is implemented as part of a bid database in the advanced protocol and not as described below for
 * the basic protocol.</b></i>
 *
 *   1. As an interim stage to fully automatic alerting, it has been decided to implement three variations
 *      of optional "manual alerting", i.e. to be used where the bidding computer does not itself make the
 *      alert and produce information about it.\n\n
 *   2. In the first variation, the Table Manager will pause after every bid except for those detailed below
 *      and will wait for the operator to input whether or not the bid is alertable.  This information will be
 *      provided by the bidding computer's operator.  In the second variation, the Table Manager will pause
 *      only if the bid is suffixed by the keyword "Alert".   In the third variation, the Table Manager will
 *      pause at the end of the auction.\n\n
 *   3. If the bid is not alertable, the pause is released and bidding continues.\n\n
 *   4. If the bid is alertable, an input dialog with be displayed on the Table Manager's computer for the
 *      entry of information (provided by the bidding computer's operator) in the format described above.
 *      The Table Manager will convert the input into an alert string as described above and will transmit it
 *      to the bidder's opponents. When bidder's left-hand opponent is ready (i.e. after right-hand opponent
 *      is ready), it will make the next bid.  Whether the alert message is parsed automatically by the
 *      receiving computer or manually by its operator is of no concern to Table Manager.\n\n
 *   5. No information beyond that defined in the protocol will be requested or given.\n\n
 *   6. Table Manager will not pause after the following bids :\n\n
 *      After any pass except\n
 *      >> Z - (Z) - pass\n
 *      >> Z - (?) - ? - (Z) - pass\n
 *     where\n
 *     >> means any prior bidding\n
 *     Z means any bid or double or redouble (and each Z may be different)\n
 *     ? means anything\n\n
 *     In the following definitions :\n\n
 *     X means a suit and, where relevant, lower-ranking than Y\n
 *     Y means a suit higher-ranking than X\n
 *     B means any suit\n
 *     NB means No Bid\n
 *     Db means double\n
 *     Any passes before the first bid are ignored\n\n
 *     1X\n
 *     1N\n
 *     1X - (NB) - 1Y\n
 *     1Y - (NB) - 2X\n
 *     (1Y) - 2X\n
 *     (1X) - Dbl\n
 *     1X - (1Y) - 1B\n
 *     1X - (1Y) - 1N\n
 *     1X - (Dbl) - 1Y\n
 *     1X - (Dbl) - 1N\n\n
 *     unless inverted minor raises are being used :\n
 *     1X - (NB) - 2X\n
 *     1X - (1Y) - 2X\n
 *     1X - (1N) - 2X\n
 *     (1X) - 1Y - (NB) - 2Y  (but pause for (1X) - 1N - (NB) - 2Y)\n\n
 *     unless negative doubles are being used :\n
 *     1X - (NB) - (1Y) - Dbl\n
 *
 *\n
 * <b>Playing</b>\n
 *
 *   1.  At the start of each trick, the Table Manager sends "[Player] to lead" to the leader or, if dummy
 *       is to lead, "Dummy to lead" to declarer.  The leader (or declarer, if dummy is to lead) must not
 *       transmit its card (see next item) until it receives this message.  The reason is to prevent
 *       synchronization errors if the leader to the current trick was the last player to the previous trick
 *       and sends the lead card to the next trick before the Table Manager has completed its housekeeping for
 *       the preceding trick. For the same reason, Table Manager will pause for one second at the end of each
 *       trick before sending the ".. to lead" message to enable the leader to the next trick to complete its
 *       end-of-trick housekeeping.\n
 *       <i><b>The advanced protocol handles the race condition described above differently. A synchronization
 *       point is inserted at the end of each trick to eliminate race conditions between Table Manager and clients.
 *       It also makes it possible to insert a waiting point for interaction with the user (Next Trick). The
 *       synchronization protocol is described in the appendix @ref synchronization "Synchronization Protocol".</b></i>\n\n
 *   2.  Opening leader sends "[Player] plays [Card]" to the Table Manager.\n\n
 *   3.  [Card] is in two character format [A K Q J T 9 8 7 6 5 4 3 2] + [S H D C]. (Note : an alternative
 *       suggestion is [suit] + [value]).\n\n
 *   4.  Each hand which is not the player sends a "ready for card" message to the Table Manager as follows :
 *       declarer and the defenders each send "[Hand] ready for  [Player]'s card to trick [trick number]"
 *       and dummy sends "[Hand] ready for dummy's card to trick [trick number]". Note that dummy will send
 *       this message for every card, since declarer will be the player of dummy’s cards.\n\n
 *   5.  The Table Manager sends "[Player] plays [Card]" to the other three players <i><b>(the advanced
 *       protocol sends "[Player] plays [Card]" to all players)</b></i>.\n\n
 *   6.  If the Table Manager receives an illegal card, it will ignore it and respond "Illegal card" to the
 *       player. It is assumed that playing programs will ensure that they do not play illegal cards so, at
 *       this stage in development, the protocol does not define what will then happen.\n\n
 *   7.  Strictly, it is not necessary to notify dummy of any cards played, but this is done by the Table Manager
 *       so that dummy’s screen can be updated during play.\n\n
 *   8.  Players other than dummy send "[Player] ready for dummy" to the Table Manager.\n\n
 *   9.  The Table Manager sends dummy’s hand to the other three players. The format is "Dummy's cards : " +
 *       [dummy’s hand] (in the format described above for a player’s hand).
 *       In a previous version of the protocol, players confirmed receipt of dummy's hand by sending to the
 *       Table Manager "[Player] received dummy".  That requirement has now been removed from the protocol.
 *       Players should simply ensure that they do not transmit the "ready for [dummy's] card to trick 1"
 *       message until they have received (and, if necessary, processed) dummy's cards.\n\n
 *   10. If it is dummy’s turn to play a card, declarer sends to the Table Manager "[Dummy] plays [Card]".
 *       Otherwise, the player sends to the Table Manager "[Player] plays [Card]".\n\n
 *   11. The Table Manager sends "[Player] plays [Card]" to the other three players and the ready-plays-echo
 *       sequence continues until all 13 tricks have been played.\n\n
 *   12. At the end of each hand, the Table Manager will send timing information to each hand in the form :
 *      "Timing - N/S : this board  [minutes:seconds],  total  [hours:minutes:seconds].  E/W : this board
 *      [minutes:seconds],  total  [hours:minutes:seconds]".\n\n
 *   13. To maintain synchronisation among all hands, every card is played and no assumptions are made about
 *       e.g. following with the last card held in a suit or claiming closing tricks.\n\n
 *   14. It is assumed that programs will track the bidding and play locally if required, so the result
 *       and/or score is not transmitted to each hand.\n\n
 *   15. The cycle is repeated until the designated number of boards have been played.\n\n
 *   16. The Table Manager sends "End of session" to each player.\n\n
 *   17. After a short pause, the Table Manager then disconnects each player from the network.\n\n
 *
 *\n
 * <b>Claiming</b>\n
 * <i><b>Claiming is not implemented in the advanced protocol.</b></i>
 *
 *   1. It has been suggested that the protocol should include provisions for programs to make and accept
 *      claims for remaining tricks.  Bearing in mind the speed of computer-players (particularly in the
 *      closing tricks) and the fact that a program receiving a claim has nothing to lose by rejecting it
 *      (in case the claiming program makes a mistake in the play-out), it is not considered necessary to
 *      include claiming in the protocol. Nevertheless, with a view to the possible future extension of the
 *      protocol to humans playing computers through an interface, the following is proposed (but not yet
 *      implemented).\n\n
 *   2. A player wishing to claim the remaining tricks sends to the Table Manager "[Player] claims".\n\n
 *   3. The Table Manager transmits "[Player] claims" to the player's opponents (if they are defending) or to
 *      the declarer (if the claim is made by a defender). The message is sent to dummy for information only
 *      so that, for example, it may update its display.\n\n
 *   4. The Table Manager also transmits the claimant's hand (see above for format).\n\n
 *   5. The recipient (but not dummy) responds "[Hand] accepts [Player's] claim" or "[Hand] rejects [Player's]
 *      claim".\n\n
 *   6. If the claim is accepted by both defenders or by declarer (as appropriate), the Table Manager sends
 *      "[Player's] claim is accepted" to declarer and both defenders.  Otherwise the Table Manager sends
 *      "[Player's] claim is rejected" to them.\n\n
 *   7. If the claim is rejected, play continues.\n\n
 *   8. If the claim is accepted, the Table Manager will treat the remaining tricks as having been won by the
 *      claiming player's partnership and will prepare for the next board as if the cards had been played out.
 *      The playing computers should do the same.\n\n
 *
 *\n
 * <b>Taking-back of bids and cards</b>\n
 * <i><b>Taking-back of bids and cards is implemented differently in the advanced protocol and not as described below for
 * the basic protocol.</b></i>
 *
 *   1. The taking back of bids and cards is not a normal part of bridge, but the matter has been raised,
 *      again in the context of humans playing against programs.\n\n
 *   2. Allowing taking-back presents considerable problems for synchronisation of network messages. It is
 *      therefore proposed that taking-back will not be allowed within this protocol.\n\n
 *   3. There is, of course, nothing to prevent a local program from pausing between the time that the interface
 *      operator enters his/her bid or card and transmitting the message to the Table Manager. If the operator
 *      wishes to retract the bid or card during that interval, that can be handled locally and the Table
 *      Manager will not be involved.\n\n
 *
 * We have produced a development prototype of the Table Manager program which is now undergoing testing.
 * Please contact us if you would like further information. Pending feedback from interested parties, no
 * changes have yet been made to the program for Claims.\n\n
 *
 * The prototype Table Manager is supplied (entirely at the discretion of Blue Chip Bridge Ltd) on an "as is"
 * basis only. It is for the personal use of the recipient as a prototype and it is not to be redistributed.
 * Full copyright and other intellectual property rights are reserved by Blue Chip Bridge Ltd.\n\n
 *
 * <b>IMPROVEMENTS</b>\n
 *
 * There are a few issues which need further consideration :\n\n
 *
 *   1. Whether the Table Manager should notify the players of the total number of boards at the start of the
 *      session?\n\n
 *   2. Whether time-limits should be imposed on the players ? To avoid complications over transmission speeds
 *      and the like, the prototype Table Manager program times each player’s response per bid/play and also
 *      keep running totals. It would then be a matter for the human participants to decide whether a
 *      participant should be penalized for unacceptable delays.\n\n
 *   3. How to ensure that messages are correctly received ? TCP/IP is generally considered to be a reliable
 *      protocol and acknowledgement messages should theoretically not be necessary.\n\n
 *   4. How to handle network time-outs and failures ?\n\n
 *   5. How to handle bidding/play out of turn ?\n\n
 *   6. How to handle illegal bids/cards ?\n\n
 *
 * @anchor synchronization
 * <b>SYNCHRONIZATION PROTOCOL</b>\n
 *
 * The purpose of the synchronization protocol is to bring the Table Manager and the 4 clients into known states
 * at the point of synchronization. The <b>basic protocol</b> relies on inserted time delays to avoid race conditions.
 * The <b>advanced protocol</b> uses the synchronization protocol to assure that race conditions are handled
 * properly.\n\n
 *
 * When entering a synchronization point the Table Manager sends "[Hand] ATTEMPT SYNCHRONIZE" to each client (player).
 * It then awaits a "[Hand] ATTEMPT SYNCHRONIZE" from each client. When all clients have responded the Table Manager
 * sends "[Hand] CONFIRM SYNCHRONIZE" to each client. The Table Manager then awaits a "[Hand] CONFIRM SYNCHRONIZE"
 * from each client. The client may make a pause before sending "[Hand] CONFIRM SYNCHRONIZE". When the Table manager
 * has received "[Hand] CONFIRM SYNCHRONIZE" from all four clients it sends "[Hand] ALL SYNCHRONIZED" to each client.\n\n
 *
 * When entering a synchronization point each client sends "[Hand] ATTEMPT SYNCHRONIZE" to the Table Manager. Each
 * client then awaits a "[Hand] ATTEMPT SYNCHRONIZE" from the Table Manager. When the Table Manager has responded
 * with this, each client sends "[Hand]ATTEMP SYNCHRONIZE" to the Table Manager. The client then awaits a
 * "[Hand]CONFIRM SYNCHRONIZE" from the Table Manager. When the Table Manager has responded with this
 * each client sends "[Hand] CONFIRM SYNCHRONIZE" to the Table Manager. The client may make a pause before sending
 * "[Hand] CONFIRM SYNCHRONIZE". The client then awaits a "[Hand] ALL SYNCHRONIZED" from the Table Manager.\n\n
 *
 * The protocol takes into account that it is not known whic of Table Manager or client enters the synchronization
 * point first.\n\n
 *
 * For this protocol to work it relies on that the Table Manager continues to its next state before sending the
 * "[Hand] ALL SYNCHRONIZED" to the clients. And it also relies on that the Table Managers next state does not
 * have an entry action that sends to any of the clients. After "[Hand] ALL SYNCHRONIZED" is sent to the clients
 * the Table Manager may perform actions which involve sending to clients.\n\n

 * @anchor PBNProtocol
 * <b>PORTABLE BRIDGE NOTATION PROTOCOL</b>\n
 *
 * The purpose of the PBN protocol is to make scoring information possible for both Table Manager and clients.
 * To make this possible a few communication messages are used.\n\n
 *
 * When a new session is started the Table Manager sends "Original PBN Stream Start. Default scoring
 * is: [Scoring method]" to clients. The scoring method is one of "IMP", "MP", "RUBBER", "PRACTICE",
 * "NOSCORE" or "FORSCORE". After that the original PBN file (if any) is sent one line at a time. The
 * end of the PBN file is signalled with a "Escape PBN Stream" message. Then a "Played PBN Stream Start"
 * message is sent from Table Manager to clients followed with PBN data for the until now played game
 * data. The end of this PBN file is also signalled with a "Escape PBN Stream" message. The two files
 * might be empty.
 */

/** @page exceptions Exceptions and asserts
 * There are a number of different ways to handle software failures. The way it is done
 * here utilize the c++ way. Exceptions can be caught in methods as
 * prescribed by the throw signature of the method, in which case they are handled
 * by the unexpected handler. Or they can propagate to the top level of the call stack,
 * in which case they are handled by the terminate handler. Resources are cleaned up
 * until the point where the unexpected handler or the terminate handler takes over.\n\n
 *
 * We distinguish in here between two types of software failures:\n
 *   - Non recoverable failures.\n
 *
 *     - Asserts are used for failures determined to be discovered during debugging.
 *       For some failures there is no doubt that they must be discovered during
 *       debugging. Others are not quite so straightforward e.g. here the lack of some of
 *       the operating system resources are considered to be a
 *       failure to be found during debugging.\n
 *       Asserts are turned off in the release version of the application, since they
 *       are assumed found in the debugging of the application.\n\n
 *
 *     - Exceptions are used for failures that initially are considered recoverable
 *       but later in the processing change status to non recoverable. These exceptions
 *       are finally caught by either the unexpected handler or the terminate handler.\n\n
 *
 *   - Recoverable failures.\n
 *
 *     - Exceptions are used for recoverable failures. Recoverable failures are not always
 *       true failures, but just exceptions which can (and should be) be handled. At the
 *       point where they are initiated it is left to the embracing activator to determine
 *       the type of failure.\n
 *       As an example here, failure in the allocation of memory starts as a
 *       recoverable failure, but is immediately considered a non recoverable failure (i.e.
 *       it is finally caught by either the unexpected handler or the terminate handler.\n
 *
 *
 * It is left to the (default) exit handler to close down the application in case of a non
 * recoverable exception.\n\n
 *
 * The application defines its own exception base class ZBridgeException, which is derived from the
 * c++ runtime_error exception. Some ZBridgeExceptions are recoverable and some are not. Other
 * exceptions in addition to ZBridgeException are considered non recoverable.\n\n
 *
 * Currently there are the following exceptions derived from ZBridgeExceptions:\n
 *
 *   - FatalException These are exceptions considered non recoverable errors.
 *   - NetProtocolException These are exceptions thrown while handling the net
 *     communication. They are considered non fatal and are just shown to the user..
 *   - PlayException These are exceptions thrown while handling the play of cards.
 *     They are considered non fatal and are just shown to the user.
 *
 * Memory allocation errors are considered fatal errors and activates immediately (unless
 * otherwise specified) the unexpected handler. This is not explicitly mentioned in the
 * documentation of the affected methods.
 *
 * I know there is some dispute about the value of c++ exceptions. I have tried to use them
 * in this application in a coherent way and in a way I find useful.\n
 * I use throw specifications for methods to let the unexpected handler catch exceptions as
 * soon as they are found non recoverable. The only real problem with that as far as I can
 * see is how to tell the user. Debugging is easy enough though and I probably won't be able to
 * tell the user anyway in these situations.
 */
